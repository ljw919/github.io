{"meta":{"title":"LJW's Secret Garden","subtitle":"","description":"","author":"LJW","url":"http://yoursite.com","root":"/"},"pages":[{"title":"标签","date":"2020-06-18T09:09:18.000Z","updated":"2020-06-19T11:45:11.485Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-06-19T03:29:19.256Z","updated":"2020-06-19T03:29:19.256Z","comments":true,"path":"category/index.html","permalink":"http://yoursite.com/category/index.html","excerpt":"","text":""},{"title":"朋友们","date":"2020-06-19T03:17:22.264Z","updated":"2020-06-19T03:17:22.264Z","comments":true,"path":"friends/index.html","permalink":"http://yoursite.com/friends/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-06-19T03:04:10.281Z","updated":"2020-06-19T03:04:10.281Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"上海大宅蟹专吃学校"},{"title":"","date":"2020-06-24T11:53:46.942Z","updated":"2020-06-24T11:53:46.918Z","comments":true,"path":"images/Const那些事.html","permalink":"http://yoursite.com/images/Const%E9%82%A3%E4%BA%9B%E4%BA%8B.html","excerpt":"","text":"Const那些事const对象默认为文件局部对象注意：非const变量默认为extern。要使const变量能够在其他文件中访问，必须在文件中显示地指定它为extern。 未被const修饰的变量在不同文件的访问12345678//file1.cppint ext; //默认为extern//file2.cpp#include &lt;iostream&gt;extern int ext;int main()&#123; std::cout&lt;&lt;(ext+10)&lt;&lt;std::endl;&#125; const常量在不同文件的访问12345678//file1.cppextern const int ext = 12;//file2.cpp#include &lt;iostream&gt;extern const int ext;int main()&#123; std::cout&lt;&lt;ext&lt;&lt;std::endl;&#125; 小结：可以发现未被const修饰的变量不需要extern显示声明！而const常量需要显示声明extern，并且需要初始化！因为常量在定义后就不能被修改，所以定义时必须初始化。 指针与const与指针相关的const有四种： 12345const char *a; //指向const对象的指针或指向常量的指针char const *a; //同上char *const a; //指向类型对象的const指针(char型常量指针)const char* const a;//指向char型常量的char型常量指针 小结：如果const位于的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；如果const位于的右侧，const就是修饰指针本身，即指针本身是常量。 具体使用如下： （1）指向常量的指针 ​ 不能使用void指针保存const对象的地址，必须用*const void ***类型的指针保存const对象的地址。 123const int p = 10;const void *vp = &amp;p;void *vp = &amp;p; //error ​ 允许把非const对象的地址赋给指向const对象的指针。 123const int *ptr;int val = 3;ptr = &amp;val; 不能通过ptr指针来修改val的值，即使它指向的是非const对象。 不能使用指向const对象的指针修改其基础对象，然而如果该指针指向了非const对象，可以用其他方式修改其所指的对象。可以修改const指针所指向的值，但是不能通过const对象指针来进行修改。 123int *ptr1 = &amp;val;*ptr1 = 4;cout&lt;&lt;*ptr&lt;&lt;endl; 小结： ​ 对于指向常量的指针，不能通过指针来修改对象的值。也不能使用void *指针保存const对象的地址，必须使用const void *类型的指针保存const对象的地址。 ​ 允许把非const对象的地址赋值给const对象的指针，如果要修改指针所指向的对象值，必须通过其他方式修改，不能直接通过当前指针直接修改。 （2） 常量指针 const指针必须进行初始化，且const指针的值不能修改。 123456789#include &lt;iostream&gt;using namespace std;int main()&#123; int num = 0; int *const ptr = &amp;num; //const指针必须初始化，并且const指针的值不能修改 int *t = &amp;num; //通过修改非常量指针指向的对象，完成修改常量指针指向的值的目的 *t = 1; //t指针指向num的地址，其指向的值(num）改为1 cout&lt;&lt;*ptr&lt;&lt;endl; //1&#125; 上述修改ptr指针所指向的值，可以通过非const指针来修改。 123456789#include &lt;iostream&gt;using namespace std;int main()&#123; const int num = 0; int * const ptr = &amp;num; //error!const int * -&gt; int *(ptr指向一个非常量) //若改为const int *ptr/const int * const ptr，可正常运行 cout&lt;&lt;*ptr&lt;&lt;endl;&#125; （3）指向常量的常指针 12const int p = 3;const int * const ptr = &amp;p; ptr是一个const指针，指向了一个int类型的const对象。 函数中使用constconst修饰函数的返回值 （1）const int 1const int func1(); （2）const int * 1const int * func2(); 指针指向的内容不变（func2函数返回值是一个指针，指向一个常量） （3）int *const 1int *const func2(); 指针本身不可变（func2函数返回一个int类型常量指针） const修饰函数参数 （1）传递过来的参数及指针本身在函数内不可变，无意义！ 12void func(const int var); //传递过来的参数不可变void func(int *const var); //指针本身不可变 表明参数在函数体内不能被修改，此处var本身就是形参不会改变，没有意义；包括传入的形参是指针也是一样。输入参数采用值传递，由于函数将自动产生临时变量以用于复制该参数，该输入参数本来就无需保护，所以不要加const修饰。 （2）参数指针所指内容为常量不可变 1void StringCopy(char *dst, const char *src) 其中src是输入参数，dst是输出参数。给src加上const修饰后，如果函数体内的语句试图改动src的内容，编译器将指出错误，这就是加了const的作用域之一。 （3）参数为引用，为了增加效率同时防止修改 1void func(const A &amp;a); 对于非内部数据类型的参数，像void func(A a)这样的声明函数注定效率比较低，因为函数体内将产生A类型的临时对象用于复制参数a，而临时对象的构造、复制、析构过程都将消耗时间。 为了提高效率，可将函数声明改为void func(A &amp;a)，因为引用传递仅借用参数别名，不产生临时对象，但它也有缺点：引用传递有可能改变参数a，这不是我门想要的，所以加const修饰。 问题：是否应将void func(int x) 改写为void func(const int &amp;x)，以便提高效率？ 答：完全没必要，因为内部数据类型的参数不存在构造、析构的过程，而复制也非常快，“值传递”和“引用传递”的效率几乎相当。 小结：对于非内部数据类型的输入参数，应该将“值传递”的方式改为“const 引用传递”，目的是提高效率；对于内部数据类型的输入参数，不要将“值传递”的方式改为“const 引用传递”。否则既达不到提高效率的目的，又降低了函数的可理解性。 类中使用const在类中，任何不会修改数据成员的函数都应该声明为const类型。如果在编写const成员函数时，不慎修改数据成员，或者调用了其他非const成员函数，编译器将报错，这无疑会提高程序的健壮性。使用const关键字声明的成员函数，称为常成员函数，只有常成员函数才有资格操作常量或者常对象，没有使用const关键字声明的成员函数不能用来操作常对象。 对于类中的const成员变量必须通过列表初始化进行初始化。 12345678910111213class Apple&#123;private: int people[100];public: Apple(int i); //构造函数声明 const int apple_number; //const数据成员&#125;;Apple::Apple(int i)::apple_number(i)//构造函数定义，使用列表初始化&#123;&#125; const对象只能访问const成员函数，而非const对象可以访问任意的成员函数，包括const成员函数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//apple.cppclass Apple&#123;private: int people[100];public: Apple(int i); const int apple_number; void take(int num) const; int add(int num); int add(int num) const; int getCount() const;&#125;;//main.cpp#include&lt;iostream&gt;#include\"apple.cpp\"using namespace std;Apple::Apple(int i):apple_number(i)&#123;&#125;int Apple::add(int num)&#123; take(num);&#125;int Apple::add(int num) const&#123; take(num);&#125;void Apple::take(int num) const&#123; cout&lt;&lt;\"take func \"&lt;&lt;num&lt;&lt;endl;&#125;int Apple::getCount() const&#123; take(1);// add(); //error return apple_number;&#125;int main()&#123; Apple a(2); cout&lt;&lt;a.getCount()&lt;&lt;endl; a.add(10); const Apple b(3); b.add(100); return 0;&#125;//编译： g++ -o main main.cpp apple.cpp//结果take func 12take func 10take func 100 除了上述的初始化const常量用初始化列表方式外，也可以通过下面方法： 一：将常量定义与static结合 1static const int apple_number 二：在外面初始化 1const int Apple::apple_number=10; 三：如果你使用C++11进行编译，直接可以在定义处初始化 123static const int apple_number=10;//orconst int apple_number=10; 这里提到了static，下面简单的说一下：在C++中，static静态成员变量不能在类的内部初始化。在类的内部只是声明，定义必须在类的外部，通常在类的实现文件中初始化。 12static int ap; //在类中声明int Apple::ap=666 //在类实现文件中使用"}],"posts":[{"title":"Const那些事","slug":"file","date":"2020-06-24T15:16:37.000Z","updated":"2020-06-24T15:20:01.145Z","comments":true,"path":"2020/06/24/file/","link":"","permalink":"http://yoursite.com/2020/06/24/file/","excerpt":"Const那些事const对象默认为文件局部对象注意：非const变量默认为extern。要使const变量能够在其他文件中访问，必须在文件中显示地指定它为extern。","text":"Const那些事const对象默认为文件局部对象注意：非const变量默认为extern。要使const变量能够在其他文件中访问，必须在文件中显示地指定它为extern。 未被const修饰的变量在不同文件的访问12345678//file1.cppint ext; //默认为extern//file2.cpp#include &lt;iostream&gt;extern int ext;int main()&#123; std::cout&lt;&lt;(ext+10)&lt;&lt;std::endl;&#125; const常量在不同文件的访问12345678//file1.cppextern const int ext = 12;//file2.cpp#include &lt;iostream&gt;extern const int ext;int main()&#123; std::cout&lt;&lt;ext&lt;&lt;std::endl;&#125; 小结：可以发现未被const修饰的变量不需要extern显示声明！而const常量需要显示声明extern，并且需要初始化！因为常量在定义后就不能被修改，所以定义时必须初始化。 指针与const与指针相关的const有四种： 12345const char *a; //指向const对象的指针或指向常量的指针char const *a; //同上char *const a; //指向类型对象的const指针(char型常量指针)const char* const a;//指向char型常量的char型常量指针 小结：如果const位于的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；如果const位于的右侧，const就是修饰指针本身，即指针本身是常量。 具体使用如下： （1）指向常量的指针 ​ 不能使用void指针保存const对象的地址，必须用*const void ***类型的指针保存const对象的地址。 123const int p = 10;const void *vp = &amp;p;void *vp = &amp;p; //error ​ 允许把非const对象的地址赋给指向const对象的指针。 123const int *ptr;int val = 3;ptr = &amp;val; 不能通过ptr指针来修改val的值，即使它指向的是非const对象。 不能使用指向const对象的指针修改其基础对象，然而如果该指针指向了非const对象，可以用其他方式修改其所指的对象。可以修改const指针所指向的值，但是不能通过const对象指针来进行修改。 123int *ptr1 = &amp;val;*ptr1 = 4;cout&lt;&lt;*ptr&lt;&lt;endl; 小结： ​ 对于指向常量的指针，不能通过指针来修改对象的值。也不能使用void *指针保存const对象的地址，必须使用const void *类型的指针保存const对象的地址。 ​ 允许把非const对象的地址赋值给const对象的指针，如果要修改指针所指向的对象值，必须通过其他方式修改，不能直接通过当前指针直接修改。 （2） 常量指针 const指针必须进行初始化，且const指针的值不能修改。 123456789#include &lt;iostream&gt;using namespace std;int main()&#123; int num = 0; int *const ptr = &amp;num; //const指针必须初始化，并且const指针的值不能修改 int *t = &amp;num; //通过修改非常量指针指向的对象，完成修改常量指针指向的值的目的 *t = 1; //t指针指向num的地址，其指向的值(num）改为1 cout&lt;&lt;*ptr&lt;&lt;endl; //1&#125; 上述修改ptr指针所指向的值，可以通过非const指针来修改。 123456789#include &lt;iostream&gt;using namespace std;int main()&#123; const int num = 0; int * const ptr = &amp;num; //error!const int * -&gt; int *(ptr指向一个非常量) //若改为const int *ptr/const int * const ptr，可正常运行 cout&lt;&lt;*ptr&lt;&lt;endl;&#125; （3）指向常量的常指针 12const int p = 3;const int * const ptr = &amp;p; ptr是一个const指针，指向了一个int类型的const对象。 函数中使用constconst修饰函数的返回值 （1）const int 1const int func1(); （2）const int * 1const int * func2(); 指针指向的内容不变（func2函数返回值是一个指针，指向一个常量） （3）int *const 1int *const func2(); 指针本身不可变（func2函数返回一个int类型常量指针） const修饰函数参数 （1）传递过来的参数及指针本身在函数内不可变，无意义！ 12void func(const int var); //传递过来的参数不可变void func(int *const var); //指针本身不可变 表明参数在函数体内不能被修改，此处var本身就是形参不会改变，没有意义；包括传入的形参是指针也是一样。输入参数采用值传递，由于函数将自动产生临时变量以用于复制该参数，该输入参数本来就无需保护，所以不要加const修饰。 （2）参数指针所指内容为常量不可变 1void StringCopy(char *dst, const char *src) 其中src是输入参数，dst是输出参数。给src加上const修饰后，如果函数体内的语句试图改动src的内容，编译器将指出错误，这就是加了const的作用域之一。 （3）参数为引用，为了增加效率同时防止修改 1void func(const A &amp;a); 对于非内部数据类型的参数，像void func(A a)这样的声明函数注定效率比较低，因为函数体内将产生A类型的临时对象用于复制参数a，而临时对象的构造、复制、析构过程都将消耗时间。 为了提高效率，可将函数声明改为void func(A &amp;a)，因为引用传递仅借用参数别名，不产生临时对象，但它也有缺点：引用传递有可能改变参数a，这不是我门想要的，所以加const修饰。 问题：是否应将void func(int x) 改写为void func(const int &amp;x)，以便提高效率？ 答：完全没必要，因为内部数据类型的参数不存在构造、析构的过程，而复制也非常快，“值传递”和“引用传递”的效率几乎相当。 小结：对于非内部数据类型的输入参数，应该将“值传递”的方式改为“const 引用传递”，目的是提高效率；对于内部数据类型的输入参数，不要将“值传递”的方式改为“const 引用传递”。否则既达不到提高效率的目的，又降低了函数的可理解性。 类中使用const在类中，任何不会修改数据成员的函数都应该声明为const类型。如果在编写const成员函数时，不慎修改数据成员，或者调用了其他非const成员函数，编译器将报错，这无疑会提高程序的健壮性。使用const关键字声明的成员函数，称为常成员函数，只有常成员函数才有资格操作常量或者常对象，没有使用const关键字声明的成员函数不能用来操作常对象。 对于类中的const成员变量必须通过列表初始化进行初始化。 12345678910111213class Apple&#123;private: int people[100];public: Apple(int i); //构造函数声明 const int apple_number; //const数据成员&#125;;Apple::Apple(int i)::apple_number(i)//构造函数定义，使用列表初始化&#123;&#125; const对象只能访问const成员函数，而非const对象可以访问任意的成员函数，包括const成员函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//apple.cppclass Apple&#123;private: int people[100];public: Apple(int i); //构造函数 const int apple_number; void take(int num) const;//成员函数 int add(int num); int add(int num) const; int getCount() const;&#125;;//main.cpp#include&lt;iostream&gt;#include\"apple.cpp\"using namespace std;Apple::Apple(int i):apple_number(i) //构造函数的定义，使用初始值列表&#123;&#125;int Apple::add(int num)&#123; //非常量成员函数定义，非const对象访问const成员函数 take(num);&#125;int Apple::add(int num) const&#123; //add成员函数重载，const对象默认选择const成员函数 take(num);&#125;void Apple::take(int num) const&#123; cout&lt;&lt;\"take func \"&lt;&lt;num&lt;&lt;endl;&#125;int Apple::getCount() const&#123; take(1);// add(); //error，const对象只能访问const成员函数，而add方法非const修饰。// 但是调用a.getCount()的对象是非const啊。。。？？？ return apple_number;&#125;int main()&#123; Apple a(2); cout&lt;&lt;a.getCount()&lt;&lt;endl; a.add(10); const Apple b(3); b.add(100); return 0;&#125;//编译： g++ -o main main.cpp apple.cpp//结果take func 12take func 10take func 100 除了上述的初始化const常量用初始化列表方式外，也可以通过下面方法： 一：将常量定义与static结合 1static const int apple_number 二：在外面初始化 1const int Apple::apple_number=10; 三：如果你使用C++11进行编译，直接可以在定义处初始化 123static const int apple_number=10;//orconst int apple_number=10; 这里提到了static，下面简单的说一下：在C++中，static静态成员变量不能在类的内部初始化。在类的内部只是声明，定义必须在类的外部，通常在类的实现文件中初始化。 12static int ap; //在类中声明int Apple::ap=666 //在类实现文件中使用","categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"C++那些事","slug":"C-那些事","permalink":"http://yoursite.com/tags/C-%E9%82%A3%E4%BA%9B%E4%BA%8B/"}]},{"title":"壁纸分享","slug":"test","date":"2020-06-18T10:26:04.000Z","updated":"2020-06-19T11:04:12.388Z","comments":true,"path":"2020/06/18/test/","link":"","permalink":"http://yoursite.com/2020/06/18/test/","excerpt":"","text":"","categories":[{"name":"fun","slug":"fun","permalink":"http://yoursite.com/categories/fun/"}],"tags":[{"name":"壁纸","slug":"壁纸","permalink":"http://yoursite.com/tags/%E5%A3%81%E7%BA%B8/"}]},{"title":"pytorch-lstm","slug":"pytorch-lstm","date":"2020-06-18T09:56:44.000Z","updated":"2020-06-19T03:31:05.702Z","comments":true,"path":"2020/06/18/pytorch-lstm/","link":"","permalink":"http://yoursite.com/2020/06/18/pytorch-lstm/","excerpt":"LSTM时间序列预测模型 长短期记忆（long short-term memory，LSTM）。本节将基于pytorch建立一个LSTM模型，以用于航班乘客数据的预测，这里将直接按照代码块进行解释。 https://stackabuse.com/time-series-prediction-using-lstm-with-pytorch-in-python/","text":"LSTM时间序列预测模型 长短期记忆（long short-term memory，LSTM）。本节将基于pytorch建立一个LSTM模型，以用于航班乘客数据的预测，这里将直接按照代码块进行解释。 https://stackabuse.com/time-series-prediction-using-lstm-with-pytorch-in-python/ 数据的预处理 1234567891011121314151617181920212223242526272829303132333435363738394041#时间序列预测模型LSTMimport torchimport torch.nn as nnimport seaborn as sns #读取seaborn的数据文件，需要ladderimport numpy as npimport pandas as pdimport matplotlib.pyplot as pltfrom sklearn.preprocessing import MinMaxScalerflight_data = sns.load_dataset(\"flights\")#print(flight_data.head())all_data = flight_data['passengers'].values.astype(float)#一共144行数据，这里设置每12个数据为一个间隔（1年为12月）#任务是根据前132个月来预测最近12个月内旅行的乘客人数。请记住，我们有144个月的记录，这意味着前132个月的数据将用于训练我们的LSTM模型，而模型性能将使用最近12个月的值进行评估。#最后待验证的数据集（月份数目）大小，数值可以修改，记得修改最后plot对应的x范围即可test_data_size = 12 train_data = all_data[:-test_data_size] #训练数据test_data = all_data[-test_data_size:] #测试数据#归一化处理减小误差scaler = MinMaxScaler(feature_range=(-1,1))train_data_normalized = scaler.fit_transform(train_data.reshape(-1,1))train_data_normalized = torch.FloatTensor(train_data_normalized).view(-1)#重点 创建读取的数据列表。#每组数据有2个元组。前一个元组有12个月份的数据，后一个元组只有一个元素，表示第13个月份的数据，用于和基于前12个数据预测的数据求lossdef create_inout_sequences(input_data, tw): inout_seq = [] L = len(input_data) for i in range(L-tw): #L-tw = 144-32 = 132个数据 train_seq = input_data[i:i+tw] #12个数据一组，进行训练 train_label = input_data[i+tw:i+tw+1] #第12+1个数据作为label计算loss inout_seq.append((train_seq, train_label)) return inout_seq#这是每次训练的数据（月份数目），设置为12个月，可以进行调整train_window = 12 #tw，设置训练输入的序列长度为12train_inout_seq = create_inout_sequences(train_data_normalized, train_window) 数据集结果如下 123456789101112131415161718192021train_inout_seq[:5][(tensor([-0.9648, -0.9385, -0.8769, -0.8901, -0.9253, -0.8637, -0.8066, -0.8066, -0.8593, -0.9341, -1.0000, -0.9385]), tensor([-0.9516])), (tensor([-0.9385, -0.8769, -0.8901, -0.9253, -0.8637, -0.8066, -0.8066, -0.8593, -0.9341, -1.0000, -0.9385, -0.9516]),tensor([-0.9033])), (tensor([-0.8769, -0.8901, -0.9253, -0.8637, -0.8066, -0.8066, -0.8593, -0.9341, -1.0000, -0.9385, -0.9516, -0.9033]), tensor([-0.8374])), (tensor([-0.8901, -0.9253, -0.8637, -0.8066, -0.8066, -0.8593, -0.9341, -1.0000, -0.9385, -0.9516, -0.9033, -0.8374]), tensor([-0.8637])), (tensor([-0.9253, -0.8637, -0.8066, -0.8066, -0.8593, -0.9341, -1.0000, -0.9385, -0.9516, -0.9033, -0.8374, -0.8637]), tensor([-0.9077]))]#数据每次移动一个位置，每移动一次，上一个列表的第二个数据成为下一个列表的第一个数据，标签label也依次向后挪动。#打印train_inout_seq列表的长度，将看到它包含120个项目。这是因为尽管训练集包含132个元素，但是序列长度为12，这意味着第一个序列由前12个项目组成，第13个项目是第一个序列的标签。同样，第二个序列从第二个项目开始，到第13个项目结束，而第14个项目是第二个序列的标签，依此类推。#包含120个项目，因为如果继续从第120个数据读取到132个数据，那么需要第133个数据来求loss，已经超出范围，无法满足了，所以最多120行。 LSTM网络搭建 ​ input_size：对应于输入中的要素数量。尽管我们的序列长度为12，但每个月我们只有1个值，即乘客总数，因此输入大小为1。 ​ hidden_layer_size：指定隐藏层的数量以及每层中神经元的数量。 ​ output_size：输出中的项目数，由于我们要预测未来1个月的乘客人数，因此输出大小为1。 ​ 在构造函数中，我们创建变量hidden_layer_size，lstm，linear和hidden_cell。LSTM算法接受三个输入：先前的隐藏状态，先前的单元状态和当前输入。该hidden_cell变量包含先前的隐藏状态和单元状态。lstm和linear层变量用于创建LSTM和线性层。 ​ 在forward方法内部，将input_seq作为参数传递给lstm图层。lstm层的输出是当前时间步的隐藏状态和单元状态以及输出。lstm图层的输出将传递到该linear图层。预计的乘客人数存储在predictions列表的最后一项中，并返回到调用函数。 12345678910111213141516171819202122class LSTM(nn.Module): def __init__(self, input_size=1, hidden_layer_size=100, output_size=1): super().__init__() self.hidden_layer_size = hidden_layer_size self.lstm = nn.LSTM(input_size, hidden_layer_size) #lstm层 self.linear = nn.Linear(hidden_layer_size, output_size) #全连接层 self.hidden_cell = (torch.zeros(1,1,self.hidden_layer_size), #hidden_cell层 torch.zeros(1,1,self.hidden_layer_size)) def forward(self, input_seq): #lstm处理序列数据，并传递到hidden_cell，输出lstm_out #输入数据格式：input(seq_len, batch, input_size) #seq_len：每个序列的长度 #batch_size:设置为1 #input_size:输入矩阵特征数 lstm_out, self.hidden_cell = self.lstm(input_seq.view(len(input_seq) ,1, -1), self.hidden_cell) #全连接层输出predictions predictions = self.linear(lstm_out.view(len(input_seq), -1)) return predictions[-1] 训练 1234567891011121314151617181920model = LSTM()loss_function = nn.MSELoss() #损失函数optimizer = torch.optim.Adam(model.parameters(), lr=0.001) #优化器epochs = 10for i in range(epochs): for seq, labels in train_inout_seq: optimizer.zero_grad() #补充作用？ model.hidden_cell = (torch.zeros(1,1,model.hidden_layer_size),torch.zeros(1,1,model.hidden_layer_size)) y_pred = model(seq) single_loss = loss_function(y_pred, labels) single_loss.backward() optimizer.step() if i%25 == 1: print(f'epoch:&#123;i:3&#125;loss: &#123;single_loss.item():10.8f&#125;')print(f'epoch: &#123;i:3&#125; loss: &#123;single_loss.item():10.10f&#125;') 预测（利用前12个点预测新点，然后将预测值作为新的输入，滚动预测下一个点） 123456789101112131415fut_pred = 12 #预测fut_pred个数据 test_inputs = train_data_normalized[-train_window:].tolist()#取出最后12个月数据为列表 待预测的数据是第133个起model.eval() #eval模式，不更新梯度#预测133~（133+11）个数据 12for i in range(fut_pred): seq = torch.FloatTensor(test_inputs[-train_window:]) #取出最后12个数据 with torch.no_grad(): model.hidden_cell = (torch.zeros(1,1,model.hidden_layer_size),torch.zeros(1,1,model.hidden_layer_size)) test_inputs.append(model(seq).item()) #每次输出一个预测值，加到列表print(test_inputs[train_window:]) #train_window起才是预测的数据(训练集中最后一组训练数据)#逆归一化回原值范围,test_inputs中排除前12个数据（训练数据）actual_predictions = scaler.inverse_transform(np.array(test_inputs[train_window:] ).reshape(-1, 1)) 绘图 12345678x = np.arange(132, 132+fut_pred, 1)plt.title('Month vs Passenger')plt.ylabel('Total Passengers')plt.grid(True)plt.autoscale(axis='x', tight=True)plt.plot(np.arange(132,144,1), test_data) #test_data只有12个数据真实值plt.plot(x, actual_predictions)plt.show() TIPS介绍几个参数 test_data_size : 原始数据集中最后待验证的数据个数，可修改 train_window : 训练数据集中，每批次训练的数据个数，可修改 fut_pred : 待预测的数据个数 LSTM输入数据格式：input(seq_len, batch_size, input_size) #seq_len/timestep：每个序列的长度 #batch_size:设置为1 #input_size:输入矩阵特征数 这里我们可以随意的修改，比如可以修改成用最后14个数据验证，每次用15个月份的数据作训练，预测100个月份的数据等等。当然一般来说，不同的问题下，最佳设置的参数不同，比如本问题中就是按1年12个月来设置是最佳的结果。","categories":[{"name":"pytorch","slug":"pytorch","permalink":"http://yoursite.com/categories/pytorch/"}],"tags":[{"name":"pytorch","slug":"pytorch","permalink":"http://yoursite.com/tags/pytorch/"},{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-06-18T03:48:00.160Z","updated":"2020-06-18T09:42:09.104Z","comments":true,"path":"2020/06/18/hello-world/","link":"","permalink":"http://yoursite.com/2020/06/18/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"},{"name":"fun","slug":"fun","permalink":"http://yoursite.com/categories/fun/"},{"name":"pytorch","slug":"pytorch","permalink":"http://yoursite.com/categories/pytorch/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"C++那些事","slug":"C-那些事","permalink":"http://yoursite.com/tags/C-%E9%82%A3%E4%BA%9B%E4%BA%8B/"},{"name":"壁纸","slug":"壁纸","permalink":"http://yoursite.com/tags/%E5%A3%81%E7%BA%B8/"},{"name":"pytorch","slug":"pytorch","permalink":"http://yoursite.com/tags/pytorch/"},{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]}
<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Const那些事</title>
      <link href="/2020/06/24/file/"/>
      <url>/2020/06/24/file/</url>
      
        <content type="html"><![CDATA[<h3 id="Const那些事"><a href="#Const那些事" class="headerlink" title="Const那些事"></a>Const那些事</h3><h4 id="const对象默认为文件局部对象"><a href="#const对象默认为文件局部对象" class="headerlink" title="const对象默认为文件局部对象"></a>const对象默认为文件局部对象</h4><p>注意：非const变量默认为extern。要使const变量能够在其他文件中访问，必须在文件中显示地指定它为extern。</p><a id="more"></a><h5 id="未被const修饰的变量在不同文件的访问"><a href="#未被const修饰的变量在不同文件的访问" class="headerlink" title="未被const修饰的变量在不同文件的访问"></a>未被const修饰的变量在不同文件的访问</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file1.cpp</span></span><br><span class="line"><span class="keyword">int</span> ext; <span class="comment">//默认为extern</span></span><br><span class="line"><span class="comment">//file2.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> ext;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;(ext+<span class="number">10</span>)&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="const常量在不同文件的访问"><a href="#const常量在不同文件的访问" class="headerlink" title="const常量在不同文件的访问"></a>const常量在不同文件的访问</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file1.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> ext = <span class="number">12</span>;</span><br><span class="line"><span class="comment">//file2.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> ext;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;ext&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小结：可以发现未被const修饰的变量不需要extern显示声明！而const常量需要显示声明extern，并且需要初始化！因为常量在定义后就不能被修改，所以定义时必须初始化。</p><h3 id="指针与const"><a href="#指针与const" class="headerlink" title="指针与const"></a>指针与const</h3><p>与指针相关的const有四种：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *a; <span class="comment">//指向const对象的指针或指向常量的指针</span></span><br><span class="line"><span class="keyword">char</span> <span class="keyword">const</span> *a; <span class="comment">//同上</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *<span class="keyword">const</span> a; <span class="comment">//指向类型对象的const指针(char型常量指针)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> a;<span class="comment">//指向char型常量的char型常量指针</span></span><br></pre></td></tr></table></figure><p>小结：如果const位于<strong><strong><em>的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；如果const位于</em></strong></strong>的右侧，const就是修饰指针本身，即指针本身是常量。</p><p>具体使用如下：</p><p>（1）指向常量的指针</p><p>​    不能使用void<em>指针保存const对象的地址，必须用*</em>const void ***类型的指针保存const对象的地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> p = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">void</span> *vp = &amp;p;</span><br><span class="line"><span class="keyword">void</span> *vp = &amp;p; <span class="comment">//error</span></span><br></pre></td></tr></table></figure><p>​    <strong>允许把非const对象的地址赋给指向const对象的指针</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *ptr;</span><br><span class="line"><span class="keyword">int</span> val = <span class="number">3</span>;</span><br><span class="line">ptr = &amp;val;</span><br></pre></td></tr></table></figure><p>不能通过ptr指针来修改val的值，即使它指向的是非const对象。</p><p>不能使用指向const对象的指针修改其基础对象，然而如果该指针指向了非const对象，可以用其他方式修改其所指的对象。<strong>可以修改const指针所指向的值</strong>，但是<strong>不能通过const对象指针来进行修改</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ptr1 = &amp;val;</span><br><span class="line">*ptr1 = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*ptr&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p><strong>小结：</strong></p><p>​            对于指向常量的指针，不能通过指针来修改对象的值。也不能使用<strong>void *</strong>指针保存const对象的地址，必须使用<strong>const void *</strong>类型的指针保存const对象的地址。</p><p>​            <strong>允许把非const对象的地址赋值给const对象的指针</strong>，如果要修改指针所指向的对象值，必须通过其他方式修改，不能直接通过当前指针直接修改。</p><p>（2） 常量指针</p><p>const指针必须进行初始化，且const指针的值不能修改。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> ptr = &amp;num; <span class="comment">//const指针必须初始化，并且const指针的值不能修改</span></span><br><span class="line"><span class="keyword">int</span> *t = &amp;num; <span class="comment">//通过修改非常量指针指向的对象，完成修改常量指针指向的值的目的</span></span><br><span class="line">*t = <span class="number">1</span>; <span class="comment">//t指针指向num的地址，其指向的值(num）改为1</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*ptr&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述修改ptr指针所指向的值，可以通过非const指针来修改。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> ptr = &amp;num;  <span class="comment">//error!const int * -&gt; int *(ptr指向一个非常量)</span></span><br><span class="line">    <span class="comment">//若改为const int *ptr/const int * const ptr，可正常运行</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*ptr&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）指向常量的常指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> p = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> ptr = &amp;p;</span><br></pre></td></tr></table></figure><p>ptr是一个const指针，指向了一个int类型的const对象。</p><h3 id="函数中使用const"><a href="#函数中使用const" class="headerlink" title="函数中使用const"></a>函数中使用const</h3><p><strong>const修饰函数的返回值</strong></p><p>（1）const int</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>（2）const int *</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="title">func2</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>指针指向的内容不变（func2函数返回值是一个指针，指向一个常量）</p><p>（3）int  *const</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="keyword">const</span> <span class="title">func2</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>指针本身不可变（func2函数返回一个int类型常量指针）</p><p><strong>const修饰函数参数</strong></p><p>（1）传递过来的参数及指针本身在函数内不可变，无意义！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> var)</span></span>;  <span class="comment">//传递过来的参数不可变</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> *<span class="keyword">const</span> var)</span></span>; <span class="comment">//指针本身不可变</span></span><br></pre></td></tr></table></figure><p>表明参数在函数体内不能被修改，此处var本身就是形参不会改变，没有意义；包括传入的形参是指针也是一样。输入参数采用值传递，由于函数将自动产生临时变量以用于复制该参数，该输入参数本来就无需保护，所以不要加const修饰。</p><p>（2）参数指针所指内容为常量不可变</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StringCopy</span><span class="params">(<span class="keyword">char</span> *dst, <span class="keyword">const</span> <span class="keyword">char</span> *src)</span></span></span><br></pre></td></tr></table></figure><p> 其中src是输入参数，dst是输出参数。给src加上const修饰后，如果函数体内的语句试图改动src的内容，编译器将指出错误，这就是加了const的作用域之一。</p><p>（3）参数为引用，为了增加效率同时防止修改</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> A &amp;a)</span></span>;</span><br></pre></td></tr></table></figure><p>对于<strong>非内部数据类型</strong>的参数，像<strong>void func(A a)</strong>这样的声明函数注定效率比较低，因为函数体内将产生A类型的临时对象用于复制参数a，而临时对象的构造、复制、析构过程都将消耗时间。</p><p>为了提高效率，可将函数声明改为<strong>void func(A &amp;a)</strong>，因为引用传递仅借用参数别名，<strong>不产生临时对象</strong>，但它也有缺点：<strong>引用传递有可能改变参数a</strong>，这不是我门想要的，所以加const修饰。</p><p><strong>问题</strong>：是否应将void func(int x) 改写为void func(const int &amp;x)，以便提高效率？</p><p><strong>答</strong>：完全没必要，因为内部数据类型的参数不存在构造、析构的过程，而复制也非常快，“值传递”和“引用传递”的效率几乎相当。</p><p><strong>小结：</strong>对于<strong>非内部数据类型</strong>的输入参数，应该将“值传递”的方式改为“const 引用传递”，目的是提高效率；对于<strong>内部数据类型</strong>的输入参数，不要将“值传递”的方式改为“const 引用传递”。否则既达不到提高效率的目的，又降低了函数的可理解性。</p><h3 id="类中使用const"><a href="#类中使用const" class="headerlink" title="类中使用const"></a>类中使用const</h3><p>在类中，任何不会修改数据成员的函数都应该声明为const类型。如果在编写const成员函数时，不慎修改数据成员，或者调用了其他非const成员函数，编译器将报错，这无疑会提高程序的健壮性。使用const关键字声明的成员函数，称为<strong>常成员函数</strong>，只有常成员函数才有资格操作常量或者常对象，没有使用const关键字声明的成员函数不能用来操作常对象。</p><p>对于类中的<strong>const成员变量</strong>必须通过<strong>列表初始化</strong>进行初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> people[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Apple(<span class="keyword">int</span> i);  <span class="comment">//构造函数声明</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> apple_number; <span class="comment">//const数据成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Apple::Apple(<span class="keyword">int</span> i)::apple_number(i)<span class="comment">//构造函数定义，使用列表初始化</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>const对象只能访问const成员函数，而非const对象可以访问任意的成员函数，包括const成员函数。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//apple.cpp</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> people[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Apple(<span class="keyword">int</span> i); <span class="comment">//构造函数</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> apple_number;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">take</span><span class="params">(<span class="keyword">int</span> num)</span> <span class="keyword">const</span></span>;<span class="comment">//成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"apple.cpp"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">Apple::Apple(<span class="keyword">int</span> i):apple_number(i)  <span class="comment">//构造函数的定义，使用初始值列表</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Apple::add</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;  <span class="comment">//非常量成员函数定义，非const对象访问const成员函数</span></span><br><span class="line">    take(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Apple::add</span><span class="params">(<span class="keyword">int</span> num)</span> <span class="keyword">const</span></span>&#123; <span class="comment">//add成员函数重载，const对象默认选择const成员函数</span></span><br><span class="line">    take(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Apple::take</span><span class="params">(<span class="keyword">int</span> num)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"take func "</span>&lt;&lt;num&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Apple::getCount</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    take(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//    add(); //error，const对象只能访问const成员函数，而add方法非const修饰。</span></span><br><span class="line"><span class="comment">//  但是调用a.getCount()的对象是非const啊。。。？？？</span></span><br><span class="line">    <span class="keyword">return</span> apple_number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Apple <span class="title">a</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a.getCount()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    a.add(<span class="number">10</span>);</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Apple <span class="title">b</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    b.add(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译： g++ -o main main.cpp apple.cpp</span></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">take func <span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">take func <span class="number">10</span></span><br><span class="line">take func <span class="number">100</span></span><br></pre></td></tr></table></figure><p>除了上述的<strong>初始化const常量</strong>用<strong>初始化列表方式</strong>外，也可以通过下面方法： </p><p>一：将常量定义与static结合</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> apple_number</span><br></pre></td></tr></table></figure><p>二：在外面初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Apple::apple_number=<span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>三：如果你使用C++11进行编译，直接可以在定义处初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> apple_number=<span class="number">10</span>;</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> apple_number=<span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>这里提到了static，下面简单的说一下：在C++中，<strong>static静态成员变量不能在类的内部初始化</strong>。<strong>在类的内部只是声明，定义必须在类的外部</strong>，通常在类的实现文件中初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> ap;  <span class="comment">//在类中声明</span></span><br><span class="line"><span class="keyword">int</span> Apple::ap=<span class="number">666</span> <span class="comment">//在类实现文件中使用</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C++那些事 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>壁纸分享</title>
      <link href="/2020/06/18/test/"/>
      <url>/2020/06/18/test/</url>
      
        <content type="html"><![CDATA[<img src="https://cdn.jsdelivr.net/gh/ljw919/photos/imgs/bg.jpg" style="zoom:33%;">]]></content>
      
      
      <categories>
          
          <category> fun </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 壁纸 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pytorch-lstm</title>
      <link href="/2020/06/18/pytorch-lstm/"/>
      <url>/2020/06/18/pytorch-lstm/</url>
      
        <content type="html"><![CDATA[<h2 id="LSTM时间序列预测模型"><a href="#LSTM时间序列预测模型" class="headerlink" title="LSTM时间序列预测模型"></a>LSTM时间序列预测模型</h2><ol><li><p>长短期记忆（long short-term memory，LSTM）。本节将基于pytorch建立一个LSTM模型，以用于航班乘客数据的预测，这里将直接按照代码块进行解释。</p><p><a href="https://stackabuse.com/time-series-prediction-using-lstm-with-pytorch-in-python/" target="_blank" rel="noopener">https://stackabuse.com/time-series-prediction-using-lstm-with-pytorch-in-python/</a></p><a id="more"></a></li><li><p>数据的预处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#时间序列预测模型LSTM</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns  <span class="comment">#读取seaborn的数据文件，需要ladder</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> MinMaxScaler</span><br><span class="line"></span><br><span class="line">flight_data = sns.load_dataset(<span class="string">"flights"</span>)</span><br><span class="line"><span class="comment">#print(flight_data.head())</span></span><br><span class="line">all_data = flight_data[<span class="string">'passengers'</span>].values.astype(float)</span><br><span class="line"></span><br><span class="line"><span class="comment">#一共144行数据，这里设置每12个数据为一个间隔（1年为12月）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#任务是根据前132个月来预测最近12个月内旅行的乘客人数。请记住，我们有144个月的记录，这意味着前132个月的数据将用于训练我们的LSTM模型，而模型性能将使用最近12个月的值进行评估。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#最后待验证的数据集（月份数目）大小，数值可以修改，记得修改最后plot对应的x范围即可</span></span><br><span class="line">test_data_size = <span class="number">12</span>   </span><br><span class="line">train_data = all_data[:-test_data_size] <span class="comment">#训练数据</span></span><br><span class="line">test_data = all_data[-test_data_size:]  <span class="comment">#测试数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#归一化处理减小误差</span></span><br><span class="line">scaler = MinMaxScaler(feature_range=(<span class="number">-1</span>,<span class="number">1</span>))</span><br><span class="line">train_data_normalized = scaler.fit_transform(train_data.reshape(<span class="number">-1</span>,<span class="number">1</span>))</span><br><span class="line">train_data_normalized = torch.FloatTensor(train_data_normalized).view(<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#重点  创建读取的数据列表。</span></span><br><span class="line"><span class="comment">#每组数据有2个元组。前一个元组有12个月份的数据，后一个元组只有一个元素，表示第13个月份的数据，用于和基于前12个数据预测的数据求loss</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_inout_sequences</span><span class="params">(input_data, tw)</span>:</span></span><br><span class="line">    inout_seq = []</span><br><span class="line">    L = len(input_data)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(L-tw):  <span class="comment">#L-tw = 144-32 = 132个数据</span></span><br><span class="line">        train_seq = input_data[i:i+tw]  <span class="comment">#12个数据一组，进行训练</span></span><br><span class="line">        train_label = input_data[i+tw:i+tw+<span class="number">1</span>]  <span class="comment">#第12+1个数据作为label计算loss</span></span><br><span class="line">        inout_seq.append((train_seq, train_label))  </span><br><span class="line">    <span class="keyword">return</span> inout_seq</span><br><span class="line"></span><br><span class="line"><span class="comment">#这是每次训练的数据（月份数目），设置为12个月，可以进行调整</span></span><br><span class="line">train_window = <span class="number">12</span>  <span class="comment">#tw，设置训练输入的序列长度为12</span></span><br><span class="line">train_inout_seq = create_inout_sequences(train_data_normalized, train_window)</span><br></pre></td></tr></table></figure><p>数据集结果如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">train_inout_seq[:<span class="number">5</span>]</span><br><span class="line">[(tensor([<span class="number">-0.9648</span>, <span class="number">-0.9385</span>, <span class="number">-0.8769</span>, <span class="number">-0.8901</span>, <span class="number">-0.9253</span>, <span class="number">-0.8637</span>, <span class="number">-0.8066</span>, <span class="number">-0.8066</span>,</span><br><span class="line">          <span class="number">-0.8593</span>, <span class="number">-0.9341</span>, <span class="number">-1.0000</span>, <span class="number">-0.9385</span>]), tensor([<span class="number">-0.9516</span>])),</span><br><span class="line"> </span><br><span class="line"> (tensor([<span class="number">-0.9385</span>, <span class="number">-0.8769</span>, <span class="number">-0.8901</span>, <span class="number">-0.9253</span>, <span class="number">-0.8637</span>, <span class="number">-0.8066</span>, <span class="number">-0.8066</span>, <span class="number">-0.8593</span>,</span><br><span class="line">          <span class="number">-0.9341</span>, <span class="number">-1.0000</span>, <span class="number">-0.9385</span>, <span class="number">-0.9516</span>]),tensor([<span class="number">-0.9033</span>])),</span><br><span class="line"> </span><br><span class="line"> (tensor([<span class="number">-0.8769</span>, <span class="number">-0.8901</span>, <span class="number">-0.9253</span>, <span class="number">-0.8637</span>, <span class="number">-0.8066</span>, <span class="number">-0.8066</span>, <span class="number">-0.8593</span>, <span class="number">-0.9341</span>,</span><br><span class="line">          <span class="number">-1.0000</span>, <span class="number">-0.9385</span>, <span class="number">-0.9516</span>, <span class="number">-0.9033</span>]), tensor([<span class="number">-0.8374</span>])),</span><br><span class="line"> </span><br><span class="line"> (tensor([<span class="number">-0.8901</span>, <span class="number">-0.9253</span>, <span class="number">-0.8637</span>, <span class="number">-0.8066</span>, <span class="number">-0.8066</span>, <span class="number">-0.8593</span>, <span class="number">-0.9341</span>, <span class="number">-1.0000</span>,</span><br><span class="line">          <span class="number">-0.9385</span>, <span class="number">-0.9516</span>, <span class="number">-0.9033</span>, <span class="number">-0.8374</span>]), tensor([<span class="number">-0.8637</span>])),</span><br><span class="line"> </span><br><span class="line"> (tensor([<span class="number">-0.9253</span>, <span class="number">-0.8637</span>, <span class="number">-0.8066</span>, <span class="number">-0.8066</span>, <span class="number">-0.8593</span>, <span class="number">-0.9341</span>, <span class="number">-1.0000</span>, <span class="number">-0.9385</span>,</span><br><span class="line">          <span class="number">-0.9516</span>, <span class="number">-0.9033</span>, <span class="number">-0.8374</span>, <span class="number">-0.8637</span>]), tensor([<span class="number">-0.9077</span>]))]</span><br><span class="line"></span><br><span class="line"><span class="comment">#数据每次移动一个位置，每移动一次，上一个列表的第二个数据成为下一个列表的第一个数据，标签label也依次向后挪动。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#打印train_inout_seq列表的长度，将看到它包含120个项目。这是因为尽管训练集包含132个元素，但是序列长度为12，这意味着第一个序列由前12个项目组成，第13个项目是第一个序列的标签。同样，第二个序列从第二个项目开始，到第13个项目结束，而第14个项目是第二个序列的标签，依此类推。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#包含120个项目，因为如果继续从第120个数据读取到132个数据，那么需要第133个数据来求loss，已经超出范围，无法满足了，所以最多120行。</span></span><br></pre></td></tr></table></figure></li><li><p>LSTM网络搭建</p><p>​     input_size：对应于输入中的要素数量。尽管我们的序列长度为12，但每个月我们只有1个值，即乘客总数，因此输入大小为1。 </p><p>​     hidden_layer_size：指定隐藏层的数量以及每层中神经元的数量。                  </p><p>​     output_size：输出中的项目数，由于我们要预测未来1个月的乘客人数，因此输出大小为1。  </p><p>​     在构造函数中，我们创建变量hidden_layer_size，lstm，linear和hidden_cell。LSTM算法接受三个输入：先前的隐藏状态，先前的单元状态和当前输入。该hidden_cell变量包含先前的隐藏状态和单元状态。lstm和linear层变量用于创建LSTM和线性层。</p><p>​    在forward方法内部，将input_seq作为参数传递给lstm图层。lstm层的输出是当前时间步的隐藏状态和单元状态以及输出。lstm图层的输出将传递到该linear图层。预计的乘客人数存储在predictions列表的最后一项中，并返回到调用函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LSTM</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, input_size=<span class="number">1</span>, hidden_layer_size=<span class="number">100</span>, output_size=<span class="number">1</span>)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.hidden_layer_size = hidden_layer_size</span><br><span class="line"></span><br><span class="line">        self.lstm = nn.LSTM(input_size, hidden_layer_size)  <span class="comment">#lstm层</span></span><br><span class="line"></span><br><span class="line">        self.linear = nn.Linear(hidden_layer_size, output_size)  <span class="comment">#全连接层</span></span><br><span class="line"></span><br><span class="line">        self.hidden_cell = (torch.zeros(<span class="number">1</span>,<span class="number">1</span>,self.hidden_layer_size), <span class="comment">#hidden_cell层</span></span><br><span class="line">                            torch.zeros(<span class="number">1</span>,<span class="number">1</span>,self.hidden_layer_size))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, input_seq)</span>:</span></span><br><span class="line">        <span class="comment">#lstm处理序列数据，并传递到hidden_cell，输出lstm_out</span></span><br><span class="line">        <span class="comment">#输入数据格式：input(seq_len, batch, input_size)</span></span><br><span class="line">        <span class="comment">#seq_len：每个序列的长度</span></span><br><span class="line">        <span class="comment">#batch_size:设置为1</span></span><br><span class="line">        <span class="comment">#input_size:输入矩阵特征数</span></span><br><span class="line">        lstm_out, self.hidden_cell = self.lstm(input_seq.view(len(input_seq) ,<span class="number">1</span>, <span class="number">-1</span>), self.hidden_cell)</span><br><span class="line">        <span class="comment">#全连接层输出predictions</span></span><br><span class="line">        predictions = self.linear(lstm_out.view(len(input_seq), <span class="number">-1</span>))</span><br><span class="line">        <span class="keyword">return</span> predictions[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><p>训练</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">model = LSTM()</span><br><span class="line">loss_function = nn.MSELoss() <span class="comment">#损失函数</span></span><br><span class="line">optimizer = torch.optim.Adam(model.parameters(), lr=<span class="number">0.001</span>)  <span class="comment">#优化器</span></span><br><span class="line"></span><br><span class="line">epochs = <span class="number">10</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(epochs):</span><br><span class="line">    <span class="keyword">for</span> seq, labels <span class="keyword">in</span> train_inout_seq:</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#补充作用？</span></span><br><span class="line">        model.hidden_cell = (torch.zeros(<span class="number">1</span>,<span class="number">1</span>,model.hidden_layer_size),torch.zeros(<span class="number">1</span>,<span class="number">1</span>,model.hidden_layer_size))</span><br><span class="line">        </span><br><span class="line">        y_pred = model(seq)</span><br><span class="line">        single_loss = loss_function(y_pred, labels)</span><br><span class="line">        single_loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">    <span class="keyword">if</span> i%<span class="number">25</span> == <span class="number">1</span>:</span><br><span class="line">        print(<span class="string">f'epoch:<span class="subst">&#123;i:<span class="number">3</span>&#125;</span>loss: <span class="subst">&#123;single_loss.item():<span class="number">10.8</span>f&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">f'epoch: <span class="subst">&#123;i:<span class="number">3</span>&#125;</span> loss: <span class="subst">&#123;single_loss.item():<span class="number">10.10</span>f&#125;</span>'</span>)</span><br></pre></td></tr></table></figure></li><li><p>预测（利用前12个点预测新点，然后将预测值作为新的输入，滚动预测下一个点）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fut_pred = <span class="number">12</span>  <span class="comment">#预测fut_pred个数据  </span></span><br><span class="line">test_inputs = train_data_normalized[-train_window:].tolist()</span><br><span class="line"><span class="comment">#取出最后12个月数据为列表 待预测的数据是第133个起</span></span><br><span class="line">model.eval()  <span class="comment">#eval模式，不更新梯度</span></span><br><span class="line"><span class="comment">#预测133~（133+11）个数据  12</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(fut_pred):</span><br><span class="line">    seq = torch.FloatTensor(test_inputs[-train_window:])  <span class="comment">#取出最后12个数据</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        model.hidden_cell = (torch.zeros(<span class="number">1</span>,<span class="number">1</span>,model.hidden_layer_size),torch.zeros(<span class="number">1</span>,<span class="number">1</span>,model.hidden_layer_size))</span><br><span class="line">        test_inputs.append(model(seq).item())  <span class="comment">#每次输出一个预测值，加到列表</span></span><br><span class="line"></span><br><span class="line">print(test_inputs[train_window:])  <span class="comment">#train_window起才是预测的数据(训练集中最后一组训练数据)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#逆归一化回原值范围,test_inputs中排除前12个数据（训练数据）</span></span><br><span class="line">actual_predictions = scaler.inverse_transform(np.array(test_inputs[train_window:] ).reshape(<span class="number">-1</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure></li><li><p>绘图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = np.arange(<span class="number">132</span>, <span class="number">132</span>+fut_pred, <span class="number">1</span>)</span><br><span class="line">plt.title(<span class="string">'Month vs Passenger'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Total Passengers'</span>)</span><br><span class="line">plt.grid(<span class="literal">True</span>)</span><br><span class="line">plt.autoscale(axis=<span class="string">'x'</span>, tight=<span class="literal">True</span>)</span><br><span class="line">plt.plot(np.arange(<span class="number">132</span>,<span class="number">144</span>,<span class="number">1</span>), test_data)  <span class="comment">#test_data只有12个数据真实值</span></span><br><span class="line">plt.plot(x, actual_predictions)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><img src="/.com//Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20200612184554673.png" alt="image-20200612184554673" style="zoom: 50%;"></li></ol><h2 id="TIPS"><a href="#TIPS" class="headerlink" title="TIPS"></a>TIPS</h2><p>介绍几个参数</p><ol><li><p>test_data_size : 原始数据集中最后待验证的数据个数，可修改</p></li><li><p>train_window : 训练数据集中，每批次训练的数据个数，可修改</p></li><li><p>fut_pred : 待预测的数据个数</p></li><li><pre><code class="python">LSTM输入数据格式：input(seq_len, batch_size, input_size)<span class="comment">#seq_len/timestep：每个序列的长度</span><span class="comment">#batch_size:设置为1</span><span class="comment">#input_size:输入矩阵特征数</span></code></pre></li></ol><p>这里我们可以随意的修改，比如可以修改成用最后14个数据验证，每次用15个月份的数据作训练，预测100个月份的数据等等。当然一般来说，不同的问题下，最佳设置的参数不同，比如本问题中就是按1年12个月来设置是最佳的结果。</p>]]></content>
      
      
      <categories>
          
          <category> pytorch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pytorch </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/06/18/hello-world/"/>
      <url>/2020/06/18/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
